<?php

abstract class BaseObject
{
    public $debug=false;
    protected $fields = array();
    protected $api_fields = array();
    protected $tableName;
    protected $auto_increment_key_field;

    private $field_types = array(
        'guid'      => '*',
        'char'      => '',
        'varchar'   => '',
        'int'       => 0,
        'tinyint'   => 0,
        'bigint'    => 0,
        'date'      => '*',  // '*' - compute at runtime
        'time'      => '*',
        'datetime'  => '*',
        'timestamp'  => '*',
        'decimal'   => 0.0,
    );

    public function __construct($values = array())
    {
        if(!is_string($this->tableName)  || empty($this->tableName) ||
            /* !is_array($this->fieldNames) || empty($this->fieldNames) || */
            !is_array($this->fields)     || empty($this->fields)) {
            throw new ServiceException(get_class($this) . " is missing Table or Field Definitions.");
        }

        if (!is_array($values)) {
            throw new ServiceException(get_class($this) . ' - invalid argument sent to constructor.', Service::InvalidParam);
        }

        foreach ($values as $fieldName => $value) {
            $fieldName = strtolower($fieldName);
            if (!isset($this->fields[$fieldName])) {
                throw new ServiceException("No such field name {$fieldName} on " . get_class($this));
            }
            $this->fields[$fieldName] = $value;
        }

        $this->api_fields = array();
        $this->primaryKeys = array();
        foreach($this->fields As $fieldName => $fieldInfo) {
            if (!empty($fieldInfo['api'])) {
                $this->api_fields[] = $fieldName;
            }
            if (!empty($fieldInfo['auto'])) {              // AutoIncrement Keys (only)
                $auto_increment_key_field = $fieldName;
            } elseif (!empty($fieldInfo['key'])) {         // Non-AutoIncrement Key Combination
                $this->primaryKeys[$fieldName]  = 'key';
            }
        }

        $this->initialize();

        /*----
        // print_r($this->api_fields);

        $fields = array();
        $sql = "DESCRIBE " . $this->tableName;
        printf("\n%s\n",$sql);
        $result = D::$dbm->query($sql);
        while($row = D::$dbm->fetchArray($result)) {
            $info = array();
            $t=explode('(', $row['Type']);
            print_r($t);
            $info['type'] = $t[0];
            if (count($t)>1) {
               $info['len'] = (int) $t[1];
            }
            $fields[$row['Field']] = $info;
        }
        print_r($fields);
        ---*/
    }

    /**
     * This magic method handles getting and setting
     */
    public function __call($methodName, array $parameters)
    {
        if (substr($methodName, 0, 3) == 'get') {
            $fieldName = lcfirst(substr($methodName, 3));
            if (isset($this->fields[$fieldName])) {
                return $this->$fieldName;
            } else {
                throw new ServiceException("No such field name $fieldName on " . get_class($this), Service::Error);
            }
        } elseif (substr($methodName, 0, 3) == 'set') {
            $fieldName = lcfirst(substr($methodName, 3));
            if (isset($this->fields[$fieldName])) {
                if(count($parameters) == 1) {
                    $this->$fieldName = $parameters[0];
                } else {
                    throw new ServiceException("Set $fieldName on " . get_class($this) . " requires exactly one parameter.", Service::Error);
                }
            } else {
                throw new ServiceException("No such field name {$fieldName} on " . get_class($this), Service::Error);
            }
        } else {
            throw new ServiceException("No such method {$methodName} on " . get_class($this), Service::Error);
        }
    }

    /////////////////////////////////////////////////////////////////////////////
    // PUBLIC //////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    /**
     * This method creates a BaseObject record on its corresponding table. If the
     * primary key on that table is an auto-incrementing key, the new value
     * generated by the database will be loaded into the resulting object. If the
     * primary key is not auto-incrementing, the object must have its primary key
     * values already set in order to create the record in the table.
     */
    public function insert($options=array())
    {
        Log::$debug=true;

        $fieldsCopy = $this->fields;
        if (!empty($auto_increment_key_field)) {
            unset($fieldsCopy[$auto_increment_key_field]);
        }

        $bindTemplate = '';
        $column_pos = array();
        $j=0;
        foreach($fieldsCopy as $fieldName => $fieldInfo) {
            $column_pos[$fieldName] = $j++;
            if ($fieldInfo['type'] === 'int' || $fieldInfo['type'] === 'tinyint' || $fieldInfo['type'] === 'bigint') {
                $bindTemplate .= 'i';
            } else {
                $bindTemplate .= 's';
            }
        }

        $fkeys = array_keys($fieldsCopy);
        $values = array();
        foreach($fkeys AS $k) {
            $values[] = $this->$k;
        }

        $fieldSet =  implode(', ', $fkeys);
        $placeholders = sqlPlaceholder( $fieldsCopy );

        $sql = "INSERT into {$this->tableName} ({$fieldSet}) VALUES {$placeholders};";
        $stmt = D::$dbm->prepare($sql);

        D::$dbm->bindParameters($stmt, $bindTemplate, $values);
        D::$dbm->execute($stmt);
        $errno = D::$dbm->getErrno();
        $affectedRows = D::$dbm->affectedRows($stmt);
        D::$dbm->closeStatement($stmt);

        if ($errno) {
            throw new ServiceException(get_class($this) . ": insert failed - " . D::$dbm->getLastError());
        }
        if ($affectedRows != 1) {
            throw new ServiceException(get_class($this) . ": insert failed -  affected rows="  . $affectedRows);
        }

        return true;
    }


    /**
     * Retrieve
     */
    public function retrieve($id=null, $options=array())
    {
        if (empty($id)) {
            return false;
        }

        $deleted = (!empty($options['deleted']));  // default: false - do not include deleted
        $stmt = false;
        try {
            $api_select_fields = D::$dbm->getSelectSet($this->api_fields);
            $sql  = "SELECT {$api_select_fields} FROM {$this->tableName}";
            $sql .= " WHERE id = ?";
            if (!$deleted) {
                $sql .= " AND deleted = 0";
            }
            $stmt = D::$dbm->prepare($sql);

            // printf("\nSQL: %s\n\n",$sql);

            $bindTemplate = 's';
            $bindParams = array($id);
            D::$dbm->bindParameters($stmt, $bindTemplate, $bindParams);
            D::$dbm->execute($stmt);
            $row = D::$dbm->fetchResult($stmt, $this->api_fields);
            D::$dbm->closeStatement($stmt);
            if ($row) {
                foreach($row as $f => $v) {
                    $this->$f = $v;
                }
                return $this;
            }
            return false;
        } catch (DatabaseException $e) {
            if ($stmt !== false) {
                D::$dbm->closeStatement($stmt);
            }
            Log::error($e->getLogMessage());
        } catch (Exception $e) {
            if ($stmt !== false) {
                D::$dbm->closeStatement($stmt);
            }
            Log::error($e->getMessage());
        }
    }

    /**
     * Update
     *
     * This method updates a BaseObject record on its corresponding table iff the PrimaryKey has been set
     *
     * @return integer AffectedRows
     */
    public function update($options=array())
    {
        if(!$this->isPrimaryKeySet()) {
            throw new ServiceException("Cannot update a " . get_class($this) . " without a primary key.", Service::Error);
        }

        $aFieldList = array_unique($this->aFieldNames);
        $aFieldValues = $this->aFields;

        foreach ($this->aPrimaryKey as $sField) {
            unset($aFieldList[$this->aFieldNames[$sField]]);
            unset($aFieldValues[$sField]);
            $aWhere[] = $this->aFieldNames[$sField] . "=?";
            $aPrimaryValues[] = $this->aFields[$this->aFieldNames[$sField]];
        }
        $sWhere = implode(' AND ', $aWhere);
        $sFieldList = implode("=?,", $aFieldList);
        $sFieldList .= "=?";
        $aValues = array_merge(array_values($aFieldValues), $aPrimaryValues);

        $sSql = "UPDATE {$this->tableName} SET {$sFieldList} WHERE {$sWhere}";
        $this->getDb()->query($sSql, $aValues);
        return $this->getDb()->affectedRows();
    }

    /**
     * This method inserts or updates a BaseObject record on its corresponding table
     *
     * @return integer AffectedRows
     */
    public function upsert($options=array())
    {
        if (array_key_exists('auto', $this->aPrimaryKey)) {
            throw new ServiceException("Cannot upsert a " . get_class($this) . " with an auto-increment primary key.", Service::Error);
        }

        // The insert
        $aFieldsCopy = $this->aFields;
        $sFieldList = implode(",", array_keys($aFieldsCopy));
        $sPlaceholders = sqlPlaceholder( $aFieldsCopy );

        $aInsertValues = array_values($aFieldsCopy);

        $sSqlInsert = "INSERT INTO {$this->tableName} ({$sFieldList}) VALUES {$sPlaceholders}";

        // The Update
        $aFieldList = array_unique($this->aFieldNames);
        $aFieldValues = $this->aFields;

        foreach ($this->aPrimaryKey as $sField) {
            unset($aFieldList[$this->aFieldNames[$sField]]);
            unset($aFieldValues[$sField]);
            $aWhere[] = $this->aFieldNames[$sField] . "=?";
            $aPrimaryValues[] = $this->aFields[$this->aFieldNames[$sField]];
        }
        $sFieldList = implode("=?,", $aFieldList);
        $sFieldList .= "=?";
        $aUpdateValues = $aFieldValues;

        $sSqlUpdate = " ON DUPLICATE KEY UPDATE {$sFieldList}";

        // The combination
        $sSql = $sSqlInsert . $sSqlUpdate;
        $aValues = array_merge($aInsertValues, $aUpdateValues);
        $this->getDb()->query($sSql, $aValues);

        return $this->getDb()->affectedRows();
    }


    /**
     * Delete
     *
     * This method deletes the row associated with the object from the relevant database table.
     * While the table interaction uses the database field names, of course, the exception thrown
     * in the event of unset Primary Keys refers to the friendly PHP name.
     *
     * @return integer
     */
    public function delete($options=array())
    {
        if(!$this->isPrimaryKeySet()) {
            $primaryKeyList = implode(',', array_keys($this->primaryKeys));
            throw new ServiceException("Cannot delete a " . get_class($this) . " without existing values for the primary key: {$primaryKeyList}.", Service::Error);
        }

        $deleted = (!empty($options['deleted']));  // default: false - do not include deleted

        $where = implode(" = ? AND ", array_keys($this->primaryKeys));
        $where .= " = ?";
        if (!$deleted) {
            $where .= " AND deleted = 0";
        }

        $keyValues = $this->getPrimaryKeys();
        $values = array_values($this->getPrimaryKeys());
        $bindTemplate = '';
        foreach($keyValues as $fieldName => $fieldInfo) {
            if ($fieldInfo['type'] === 'int' || $fieldInfo['type'] == 'tinyint' || $fieldInfo['type'] == 'bigint') {
                $bindTemplate .= 'i';
            } else {
                $bindTemplate .= 's';
            }
        }

        $sql = "DELETE FROM {$this->tableName} WHERE {$where}";
        $stmt = D::$dbm->prepare($sql);
        D::$dbm->bindParameters($stmt, $bindTemplate, $values);
        D::$dbm->execute($stmt);
        $affectedRows = D::$dbm->affectedRows($stmt);
        D::$dbm->closeStatement($stmt);

        return $affectedRows;
    }



    /**
     * Renames API-specific field names to standard field names.  Preserves fields
     * that are named the same in the standard and API field name definitions.
     *
     * @param array $aParams  Array of data supplied by the API user  required=true
     * @param boolean $bFillMissing If true, set params not supplied to null
     * @return array array of parameters mapped to php names
     */
    public function fromApi($aParams, $bFillMissing=false)
    {
        foreach ($this->aApiFieldNames AS $sObjectFieldName => $sApiFieldName) {
            if ($sObjectFieldName != $sApiFieldName && array_key_exists($sApiFieldName, $aParams)) {
                $aParams[$sObjectFieldName] = $aParams[$sApiFieldName];
                unset($aParams[$sApiFieldName]);
            }
            if ($bFillMissing && !array_key_exists($sObjectFieldName, $aParams)) {
                $aParams[$sObjectFieldName] = null;
            }
        }

        return $aParams;
    }

    /**
     * Checks if an API alias exists for a given field, and returns the alias if it exists or the key if not
     *
     * @param string $sKey
     * @return string
     */
    public function getApiKey($sKey)
    {
        if (array_key_exists( $sKey, $this->aApiFieldNames )) {
            return $this->aApiFieldNames[$sKey];
        } else {
            return $sKey;
        }
    }

    /**
     * Checks if a standard database name exists exists for a given API field, and returns the alias if it exists or the key if not
     *
     * @param string $sKey
     * @return string
     */
    public function getDbKey($sKey)
    {
        $sReturnKey = array_search($sKey, $this->aApiFieldNames);
        if (!$sReturnKey) {
            return $sKey;
        } else {
            return $sReturnKey;
        }
    }

    /**
     * Translates API orderby parameters to DB fields, and returns the new orderby
     * string in an array with a warning string set if there were any issues.
     *
     * @param string $sOrderBy
     * @return array ( sOrderBy string/null, sWarning string/null )
     */
    public function getDbKeyOrderBy($sOrderBy)
    {
        $aRaw = ($sOrderBy != "") ? explode(',', $sOrderBy) : array();
        $aText = array();
        $sWarning = null;

        foreach ($aRaw as $sField) {
            if ($sField != "") {
                $aPair = explode(':', $sField);
                $aPair[0] = $this->getDBKey($aPair[0]);
            } else {
                $aPair = array();
            }

            if( !count($aPair) || $aPair[0] == "" ) {
                $sWarning = "The orderby attribute was improperly formatted. Please use orderby=field1:ASC to sort by field1, ascending order; please use orderby=field1:DESC to sort by field2, descending order.";
            } elseif( count($aPair) == 1 ) {
                $aText[] = $aPair[0] . " ASC";
            } else {
                $sSortType = strtoupper($aPair[1]);

                if( strtoupper($sSortType) == "DESC" ) {
                    $aText[] = $aPair[0] . " DESC";
                } elseif( strtoupper($sSortType) == "ASC" ) {
                    $aText[] = $aPair[0] . " ASC";
                } else {
                    // default to ASC
                    $aText[] = $aPair[0] . " ASC";
                    $sWarning = "The orderby attribute was improperly formatted. Please use orderby=field1:ASC to sort by field1, ascending order; please use orderby=field1:DESC to sort by field2, descending order.";
                }
            }
        }

        return array("aOrderBy" => $aText, "sWarning" => $sWarning);
    }

    /**
     * This method returns the value of the PrimaryKey
     *
     * @return array An array of primary key values
     */
    public function getPrimaryKeys()
    {
        $keyValues = array();
        foreach($this->primaryKeys AS $fieldName => $keyType) {
            $keyValues[$fieldName] = $this->$fieldName;
        }
        return $keyValues;
    }

    /**
     * Returns an array of all field names for the object
     *
     * @return array
     */
    public function getFieldNames()
    {
        return array_keys($this->fields);
    }

    /**
     * Returns an array of API-only Fields and Values for the object
     *
     * @return array
     */
    public function toApi()
    {
        $apiFields = array();
        foreach ($this->api_fields as $fieldName) {
            $apiFields[$fieldName] = $this->fieldName;
        }
        return $apiFields;
    }

    /**
     * Returns an array of All Fields and Values for the object
     *
     * @return array
     */
    public function toArray()
    {
        $fields = array();
        foreach($this->fields As $fieldName => $fieldInfo) {
            $fields[$fieldName] = $this->$fieldName;
        }
        return $fields;
    }

    /**
     * Answer whether a field defined as Primary Key is Set (!empty)
     *
     * @return boolean
     */
    public function isPrimaryKeySet()
    {
        if (!empty($this->primaryKeys['key'])) {
            $fieldName = $this->primaryKeys['key'];
            return !empty($this->$fieldName);
        }
        return true;  // Primary Key is Set (or there is no Primary Key Defined)
    }


    //----------------------------------------------------------
    // PROTECTED Methods
    //----------------------------------------------------------



    //----------------------------------------------------------
    // PRIVATE Methods
    //----------------------------------------------------------

    /*-------------------------
     gmdate(format,timestamp);

    Parameter 	Description
         format 	Required.
    Specifies the format of the outputted date string. The following characters can be used:

    d - The day of the month (from 01 to 31)
    D - A textual representation of a day (three letters)
    j - The day of the month without leading zeros (1 to 31)
    l (lowercase 'L') - A full textual representation of a day
    N - The ISO-8601 numeric representation of a day (1 for Monday, 7 for Sunday)
    S - The English ordinal suffix for the day of the month (2 characters st, nd, rd or th. Works well with j)
    w - A numeric representation of the day (0 for Sunday, 6 for Saturday)
    z - The day of the year (from 0 through 365)
    W - The ISO-8601 week number of year (weeks starting on Monday)
    F - A full textual representation of a month (January through December)
    m - A numeric representation of a month (from 01 to 12)
    M - A short textual representation of a month (three letters)
    n - A numeric representation of a month, without leading zeros (1 to 12)
    t - The number of days in the given month
    L - Whether it's a leap year (1 if it is a leap year, 0 otherwise)
    o - The ISO-8601 year number
    Y - A four digit representation of a year
    y - A two digit representation of a year
    a - Lowercase am or pm
    A - Uppercase AM or PM
    B - Swatch Internet time (000 to 999)
    g - 12-hour format of an hour (1 to 12)
    G - 24-hour format of an hour (0 to 23)
    h - 12-hour format of an hour (01 to 12)
    H - 24-hour format of an hour (00 to 23)
    i - Minutes with leading zeros (00 to 59)
    s - Seconds, with leading zeros (00 to 59)
    u - Microseconds (added in PHP 5.2.2)
    e - The timezone identifier (Examples: UTC, GMT, Atlantic/Azores)
    I (capital i) - Whether the date is in daylights savings time (1 if Daylight Savings Time, 0 otherwise)
    O - Difference to Greenwich time (GMT) in hours (Example: +0100)
    P - Difference to Greenwich time (GMT) in hours:minutes (added in PHP 5.1.3)
    T - Timezone abbreviations (Examples: EST, MDT)
    Z - Timezone offset in seconds. The offset for timezones west of UTC is negative (-43200 to 50400)
    c - The ISO-8601 date (e.g. 2013-05-05T16:34:42+00:00)
    r - The RFC 2822 formatted date (e.g. Fri, 12 Apr 2013 12:01:05 +0200)
    U - The seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)

          and the following predefined constants can also be used (available since PHP 5.1.0):

    DATE_ATOM - Atom (example: 2013-04-12T15:52:01+00:00)
    DATE_COOKIE - HTTP Cookies (example: Friday, 12-Apr-13 15:52:01 UTC)
    DATE_ISO8601 - ISO-8601 (example: 2013-04-12T15:52:01+0000)
    DATE_RFC822 - RFC 822 (example: Fri, 12 Apr 13 15:52:01 +0000)
    DATE_RFC850 - RFC 850 (example: Friday, 12-Apr-13 15:52:01 UTC)
    DATE_RFC1036 - RFC 1036 (example: Fri, 12 Apr 13 15:52:01 +0000)
    DATE_RFC1123 - RFC 1123 (example: Fri, 12 Apr 2013 15:52:01 +0000)
    DATE_RFC2822 - RFC 2822 (Fri, 12 Apr 2013 15:52:01 +0000)
    DATE_RFC3339 - Same as DATE_ATOM (since PHP 5.1.3)
    DATE_RSS - RSS (Fri, 12 Aug 2013 15:52:01 +0000)
    DATE_W3C - World Wide Web Consortium (example: 2013-04-12T15:52:01+00:00)


     //----------------------------
     The DATE type is used for values with a date part but no time part. MySQL retrieves and displays DATE
     values in 'YYYY-MM-DD' format. The supported range is '1000-01-01' to '9999-12-31'.

     The DATETIME type is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME
     values in 'YYYY-MM-DD HH:MM:SS' format. The supported range is '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.

     The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP
     has a range of '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.

     MySQL converts TIMESTAMP values from the current time zone to UTC for storage, and back from UTC to the
     current time zone for retrieval. (This does not occur for other types such as DATETIME.) By default, the current
     time zone for each connection is the server's time. The time zone can be set on a per-connection basis. As long
     as the time zone setting remains constant, you get back the same value you store. If you store a TIMESTAMP value,
     and then change the time zone and retrieve the value, the retrieved value is different from the value you stored.
     This occurs because the same time zone was not used for conversion in both directions. The current time zone is
     available as the value of the time_zone system variable. For more information, see Section 10.6, “MySQL Server
     Time Zone Support”.

     The TIMESTAMP data type offers automatic initialization and updating to the current date and time. For
     more information, see Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”.
     --------*/


    /**
     * Initialize All fields to their defaults based on type
     */
    private function initialize()
    {
        $tm = time();
        foreach($this->fields AS $fieldName => $fieldInfo) {
            $type = $fieldInfo['type'];
            if (!isset($this->field_types[$type])) {
                throw new ServiceException(get_class($this) . " - initialize(): Invalid Field Type: ({$type})");
            }
            $val = $this->field_types[$type];

            if ($val === '*') {
                $val = null;
                switch($type) {
                    case 'guid': {
                        if (!empty($this->primaryKeys[$fieldName]) && $this->primaryKeys[$fieldName] === 'key') {
                            $val=GUID();
                        }
                        break;
                    }
                    case 'date': {
                        $val = gmdate("Y-m-d",$tm);
                        break;
                    }
                    case 'time': {
                        $val = gmdate("H:i:s",$tm);
                        break;
                    }
                    case 'datetime': {
                        $val = gmdate("Y-m-d H:i:s",$tm);
                        break;
                    }
                    case 'timestamp': {
                        $val = gmdate("Y-m-d H:i:s",$tm);
                        break;
                    }
                    default: break;
                }
            }
            $this->$fieldName = $val;
        }
    }

}
